//! Distributed Key Generation protocol as described in Fig. 4 of the paper [VSS from Distributed ZK Proofs and Applications](https://eprint.iacr.org/2023/992.pdf)

#![allow(non_snake_case)]

use crate::{
    common::{ParticipantId, ShareId},
    error::SSError,
    shamir_ss,
};
use ark_ec::{AffineRepr, CurveGroup};
use ark_ff::PrimeField;
use ark_poly::{univariate::DensePolynomial, DenseUVPolynomial, Polynomial};
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use ark_std::{cfg_into_iter, collections::BTreeMap, rand::RngCore, vec, vec::Vec, UniformRand};
use digest::Digest;
use dock_crypto_utils::expect_equality;
#[cfg(feature = "serde")]
use dock_crypto_utils::serde_utils::ArkObjectBytes;
use schnorr_pok::compute_random_oracle_challenge;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
#[cfg(feature = "serde")]
use serde_with::serde_as;
use zeroize::{Zeroize, ZeroizeOnDrop};

#[cfg(feature = "parallel")]
use rayon::prelude::*;

pub const DEFAULT_SALT_SIZE: usize = 128;
pub const DEFAULT_DIGEST_SIZE: usize = 64;

pub const DOMAIN_SEPARATOR: &[u8] = b"abcp_dkg";

/// Share of the secret generated by a party
#[cfg_attr(feature = "serde", cfg_eval::cfg_eval, serde_with::serde_as)]
#[derive(
    Clone, Debug, PartialEq, Eq, Zeroize, ZeroizeOnDrop, CanonicalSerialize, CanonicalDeserialize,
)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct VerifiableShare<F: PrimeField, const SALT_SIZE: usize = DEFAULT_SALT_SIZE> {
    /// Share id. Corresponds to the participant id.
    #[zeroize(skip)]
    pub id: ShareId,
    /// At least `threshold` number of shares are needed to reconstruct the secret
    #[zeroize(skip)]
    pub threshold: ShareId,
    #[cfg_attr(feature = "serde", serde_as(as = "ArkObjectBytes"))]
    pub share: F,
    #[cfg_attr(feature = "serde", serde_as(as = "[_; SALT_SIZE]"))]
    pub blinding: [u8; SALT_SIZE],
    #[cfg_attr(feature = "serde", serde_as(as = "[_; SALT_SIZE]"))]
    pub blinding_prime: [u8; SALT_SIZE],
}

/// State of a party in Round 1.
/// CMG is the group where commitments reside and PKG is the group of the public key
#[derive(Clone, Debug, PartialEq, Eq, CanonicalSerialize, CanonicalDeserialize)]
pub struct Round1<
    PKG: AffineRepr,
    const SALT_SIZE: usize = DEFAULT_SALT_SIZE,
    const DIGEST_SIZE: usize = DEFAULT_DIGEST_SIZE,
> {
    pub id: ParticipantId,
    pub threshold: ShareId,
    pub secret: PKG::ScalarField,
    pub h: PKG,
    pub shares: Vec<VerifiableShare<PKG::ScalarField, SALT_SIZE>>,
    pub y_0: [u8; SALT_SIZE],
    pub y_0_prime: [u8; SALT_SIZE],
    /// Stores broadcast messages received from other parties in this round
    pub received_msgs: BTreeMap<ParticipantId, Round1Msg<PKG::ScalarField, DIGEST_SIZE>>,
}

/// Message broadcasted by a party in Round 1
/// CMG is the group where commitments reside and PKG is the group of the public key
#[derive(Clone, Debug, PartialEq, Eq, CanonicalSerialize, CanonicalDeserialize)]
pub struct Round1Msg<F: PrimeField, const DIGEST_SIZE: usize = DEFAULT_DIGEST_SIZE> {
    pub sender_id: ParticipantId,
    /// Commitments to the shares of the blinding
    pub C: Vec<[u8; DIGEST_SIZE]>,
    pub C_0: [u8; DIGEST_SIZE],
    /// Commitments to the shares which will be opened in the second round
    pub C_prime: Vec<[u8; DIGEST_SIZE]>,
    pub C_0_prime: [u8; DIGEST_SIZE],
    pub resp: DensePolynomial<F>,
}

/// State of a party in Round 1.
/// CMG is the group where commitments reside and PKG is the group of the public key
#[derive(Clone, Debug, PartialEq, Eq, CanonicalSerialize, CanonicalDeserialize)]
pub struct Round2<
    PKG: AffineRepr,
    const SALT_SIZE: usize = DEFAULT_SALT_SIZE,
    const DIGEST_SIZE: usize = DEFAULT_DIGEST_SIZE,
> {
    pub round1_state: Round1<PKG, SALT_SIZE, DIGEST_SIZE>,
    /// Stores broadcast messages received from other parties in this round
    pub received_msgs: BTreeMap<ParticipantId, Round2Msg<PKG, SALT_SIZE>>,
    /// Stores shares received from other parties in this round
    pub received_shares: BTreeMap<ParticipantId, VerifiableShare<PKG::ScalarField, SALT_SIZE>>,
}

/// Message broadcasted by a party in Round 2
#[derive(Clone, Debug, PartialEq, Eq, CanonicalSerialize, CanonicalDeserialize)]
pub struct Round2Msg<PKG: AffineRepr, const SALT_SIZE: usize = DEFAULT_SALT_SIZE> {
    pub sender_id: ParticipantId,
    pub h: PKG,
    // Question: Is `y_0` needed since `g, h`, etc will already be hashed into the challenge
    pub y_0: [u8; SALT_SIZE],
    pub y_0_prime: [u8; SALT_SIZE],
}

impl<PKG: AffineRepr, const SALT_SIZE: usize, const DIGEST_SIZE: usize>
    Round1<PKG, SALT_SIZE, DIGEST_SIZE>
{
    /// At least `threshold` number of shares are needed to reconstruct the secret
    /// `total` is the total number of participants
    pub fn start<'a, R: RngCore, D: Digest, CMG: AffineRepr<ScalarField = PKG::ScalarField>>(
        rng: &mut R,
        participant_id: ParticipantId,
        threshold: ShareId,
        total: ShareId,
        comm_key: CMG,
        pk_gen: impl Into<&'a PKG> + Clone,
    ) -> Result<(Self, Round1Msg<PKG::ScalarField, DIGEST_SIZE>), SSError> {
        if participant_id == 0 || participant_id > total {
            return Err(SSError::InvalidParticipantId(participant_id));
        }
        let secret = PKG::ScalarField::rand(rng);
        let (shares, f) = shamir_ss::deal_secret(rng, secret, threshold, total)?;
        let b = <DensePolynomial<PKG::ScalarField> as DenseUVPolynomial<PKG::ScalarField>>::rand(
            threshold as usize - 1,
            rng,
        );
        debug_assert_eq!(f.degree(), b.degree());
        let b_evals = cfg_into_iter!(1..=total)
            .map(|i| b.evaluate(&PKG::ScalarField::from(i)))
            .collect::<Vec<_>>();
        let b_0 = b.coeffs[0];
        let y = (0..total)
            .map(|_| Self::get_random_salt(rng))
            .collect::<Vec<_>>();
        let y_prime = (0..total)
            .map(|_| Self::get_random_salt(rng))
            .collect::<Vec<_>>();
        let y_0 = Self::get_random_salt(rng);
        let y_0_prime = Self::get_random_salt(rng);
        let pk_gen = pk_gen.into().into_group();
        let h = pk_gen * secret;
        let C_0 = hash_commitment::<_, D, DIGEST_SIZE>(pk_gen * b_0, &y_0);
        let C_0_prime = hash_commitment::<_, D, DIGEST_SIZE>(pk_gen + h, &y_0_prime);
        let C = cfg_into_iter!(0..total as usize)
            .map(|i| hash_commitment::<_, D, DIGEST_SIZE>(comm_key * b_evals[i], &y[i]))
            .collect::<Vec<_>>();
        let C_prime = cfg_into_iter!(0..total as usize)
            .map(|i| hash_commitment::<_, D, DIGEST_SIZE>(shares.0[i].share, &y_prime[i]))
            .collect::<Vec<_>>();

        let mut chal_bytes = vec![];
        comm_key.serialize_compressed(&mut chal_bytes)?;
        C_0.serialize_compressed(&mut chal_bytes)?;
        C_0_prime.serialize_compressed(&mut chal_bytes)?;
        for i in 0..C.len() {
            C[i].serialize_compressed(&mut chal_bytes)?;
            C_prime[i].serialize_compressed(&mut chal_bytes)?;
        }
        let d = compute_random_oracle_challenge::<PKG::ScalarField, D>(&chal_bytes);
        let r = &b - &(&f * d);
        let msg = Round1Msg {
            sender_id: participant_id,
            C,
            C_prime,
            C_0,
            C_0_prime,
            resp: r,
        };
        let shares = cfg_into_iter!(shares.0)
            .zip(cfg_into_iter!(y))
            .zip(cfg_into_iter!(y_prime))
            .map(|((s, y_i), y_i_prime)| VerifiableShare {
                id: s.id,
                threshold,
                share: s.share,
                blinding: y_i,
                blinding_prime: y_i_prime,
            })
            .collect::<Vec<_>>();
        let state = Round1 {
            id: participant_id,
            threshold,
            secret,
            h: h.into_affine(),
            shares,
            y_0,
            y_0_prime,
            received_msgs: BTreeMap::new(),
        };
        Ok((state, msg))
    }

    pub fn add_received_message(
        &mut self,
        msg: Round1Msg<PKG::ScalarField, DIGEST_SIZE>,
    ) -> Result<(), SSError> {
        if msg.sender_id == self.id {
            return Err(SSError::SenderIdSameAsReceiver(msg.sender_id, self.id));
        }
        if self.received_msgs.contains_key(&msg.sender_id) {
            return Err(SSError::AlreadyProcessedFromSender(msg.sender_id));
        }
        if msg.resp.degree() != self.threshold as usize - 1 {
            return Err(SSError::DoesNotSupportThreshold(self.threshold));
        }
        expect_equality!(
            msg.C.len(),
            msg.C_prime.len(),
            SSError::InvalidNoOfCommitments
        );
        expect_equality!(
            msg.C.len(),
            self.shares.len(),
            SSError::InvalidNoOfCommitments
        );
        self.received_msgs.insert(msg.sender_id, msg);
        Ok(())
    }

    /// This should be called after "sufficient" messages have been received.
    /// "sufficient" might be just the threshold or greater depending on the number of faults to be
    /// tolerated.
    pub fn finish(
        self,
    ) -> Result<
        (
            Round2<PKG, SALT_SIZE, DIGEST_SIZE>,
            Round2Msg<PKG, SALT_SIZE>,
        ),
        SSError,
    > {
        // +1 because `self.received_msgs` does not contain message from itself
        if self.threshold > (self.received_msgs.len() as ParticipantId + 1) {
            return Err(SSError::BelowThreshold(
                self.threshold,
                self.received_msgs.len() as ParticipantId,
            ));
        }
        let round1_state = self.clone();
        let msg = Round2Msg {
            sender_id: self.id,
            h: self.h,
            y_0: self.y_0,
            y_0_prime: self.y_0_prime,
        };
        let round2 = Round2 {
            round1_state,
            received_msgs: BTreeMap::new(),
            received_shares: BTreeMap::new(),
        };
        Ok((round2, msg))
    }

    fn get_random_salt<R: RngCore>(rng: &mut R) -> [u8; SALT_SIZE] {
        let mut s = [0; SALT_SIZE];
        rng.fill_bytes(&mut s);
        s
    }
}

impl<PKG: AffineRepr, const SALT_SIZE: usize, const DIGEST_SIZE: usize>
    Round2<PKG, SALT_SIZE, DIGEST_SIZE>
{
    pub fn add_received_message(&mut self, msg: Round2Msg<PKG, SALT_SIZE>) -> Result<(), SSError> {
        if self.round1_state.id == msg.sender_id {
            return Err(SSError::SenderIdSameAsReceiver(
                self.round1_state.id,
                msg.sender_id,
            ));
        }
        if self.received_msgs.contains_key(&msg.sender_id) {
            return Err(SSError::AlreadyProcessedFromSender(msg.sender_id));
        }
        if !self.round1_state.received_msgs.contains_key(&msg.sender_id) {
            return Err(SSError::ParticipantNotAllowedInPhase2(msg.sender_id));
        }
        self.received_msgs.insert(msg.sender_id, msg);
        Ok(())
    }

    pub fn add_received_share<'a, D: Digest, CMG: AffineRepr<ScalarField = PKG::ScalarField>>(
        &mut self,
        sender_id: ParticipantId,
        share: VerifiableShare<PKG::ScalarField, SALT_SIZE>,
        comm_key: CMG,
        pk_gen: impl Into<&'a PKG> + Clone,
    ) -> Result<(), SSError> {
        if self.round1_state.id == sender_id {
            return Err(SSError::SenderIdSameAsReceiver(
                self.round1_state.id,
                sender_id,
            ));
        }
        if self.round1_state.id != share.id {
            return Err(SSError::UnequalParticipantAndShareId(
                self.round1_state.id,
                share.id,
            ));
        }
        if self.received_shares.contains_key(&sender_id) {
            return Err(SSError::AlreadyProcessedFromSender(sender_id));
        }
        self.verify_share::<D, CMG>(sender_id, &share, comm_key, pk_gen)?;
        self.received_shares.insert(sender_id, share);
        Ok(())
    }

    pub fn finish(self) -> Result<(PKG::ScalarField, PKG, PKG), SSError> {
        // +1 because `self.received_msgs` does not contain message from itself
        if self.round1_state.threshold > (self.received_msgs.len() as ParticipantId + 1) {
            return Err(SSError::BelowThreshold(
                self.round1_state.threshold,
                self.received_msgs.len() as ParticipantId,
            ));
        }
        if self.received_shares.len() != self.round1_state.received_msgs.len() {
            return Err(SSError::MissingSomeParticipants(
                (self.received_shares.len() - self.received_msgs.len()) as ParticipantId,
            ));
        }
        let tpk =
            self.received_msgs.values().map(|m| m.h).sum::<PKG::Group>() + self.round1_state.h;
        Ok((
            self.round1_state.secret,
            self.round1_state.h,
            tpk.into_affine(),
        ))
    }

    /// Verify a received share. Used during normal operation or in processing complaints
    pub fn verify_share<'a, D: Digest, CMG: AffineRepr<ScalarField = PKG::ScalarField>>(
        &self,
        sender_id: ParticipantId,
        share: &VerifiableShare<PKG::ScalarField, SALT_SIZE>,
        comm_key: CMG,
        pk_gen: impl Into<&'a PKG> + Clone,
    ) -> Result<(), SSError> {
        let round1_msg = self
            .round1_state
            .received_msgs
            .get(&sender_id)
            .ok_or(SSError::ParticipantNotAllowedInPhase2(sender_id))?;
        let round2_msg = self
            .received_msgs
            .get(&sender_id)
            .ok_or(SSError::MissingRound2MessageFrom(sender_id))?;
        let self_idx = self.round1_state.id as usize - 1;
        if hash_commitment::<_, D, DIGEST_SIZE>(share.share, &share.blinding_prime)
            != round1_msg.C_prime[self_idx]
        {
            return Err(SSError::InvalidShare);
        }
        let pk_gen = *pk_gen.into();
        if hash_commitment::<_, D, DIGEST_SIZE>(pk_gen + round2_msg.h, &round2_msg.y_0_prime)
            != round1_msg.C_0_prime
        {
            return Err(SSError::InvalidShare);
        }
        let mut chal_bytes = vec![];
        comm_key.serialize_compressed(&mut chal_bytes)?;
        round1_msg.C_0.serialize_compressed(&mut chal_bytes)?;
        round1_msg.C_0_prime.serialize_compressed(&mut chal_bytes)?;
        for i in 0..round1_msg.C.len() {
            round1_msg.C[i].serialize_compressed(&mut chal_bytes)?;
            round1_msg.C_prime[i].serialize_compressed(&mut chal_bytes)?;
        }
        let d = compute_random_oracle_challenge::<PKG::ScalarField, D>(&chal_bytes);
        let h_prime = pk_gen * round1_msg.resp.coeffs[0] + round2_msg.h * d;
        if round1_msg.C_0 != hash_commitment::<_, D, DIGEST_SIZE>(h_prime, &round2_msg.y_0) {
            return Err(SSError::InvalidShare);
        }
        if round1_msg.C[self_idx]
            != hash_commitment::<_, D, DIGEST_SIZE>(
                comm_key
                    * (round1_msg
                        .resp
                        .evaluate(&PKG::ScalarField::from(self.round1_state.id))
                        + share.share * d),
                &share.blinding,
            )
        {
            return Err(SSError::InvalidShare);
        }
        Ok(())
    }

    /// Called when got >= `threshold` complaints for `participant_id` and disqualifying a participant
    pub fn remove_participant(&mut self, participant_id: ParticipantId) -> Result<(), SSError> {
        if self.round1_state.id == participant_id {
            return Err(SSError::CannotRemoveSelf(participant_id));
        }
        self.received_shares.remove(&participant_id);
        self.round1_state.received_msgs.remove(&participant_id);
        Ok(())
    }

    /// Get share given by party with id `id`.
    pub fn get_share_of_party(
        &self,
        id: ParticipantId,
    ) -> Option<&VerifiableShare<PKG::ScalarField, SALT_SIZE>> {
        self.received_shares.get(&id)
    }
}

/// Commit to the message and salt using a hash function. Hash function is used because these commitments
/// are verified using a commit and reveal approach.
pub fn hash_commitment<T: CanonicalSerialize, D: Digest, const DIGEST_SIZE: usize>(
    msg: T,
    salt: &[u8],
) -> [u8; DIGEST_SIZE] {
    let serz_size = T::compressed_size(&msg);
    let mut bytes = Vec::with_capacity(serz_size + salt.len() + DOMAIN_SEPARATOR.len());
    msg.serialize_compressed(&mut bytes).unwrap();
    bytes.extend_from_slice(DOMAIN_SEPARATOR);
    bytes.extend_from_slice(salt);
    let d = D::digest(&bytes);
    d.as_slice().try_into().expect("Wrong length")
}

#[cfg(test)]
pub mod tests {
    use super::*;
    use ark_bls12_381::{G1Affine, G2Affine};
    use ark_ec::CurveGroup;
    use ark_ff::PrimeField;
    use ark_std::rand::{rngs::StdRng, SeedableRng};
    use blake2::Blake2b512;
    use std::time::{Duration, Instant};

    #[test]
    fn distributed_key_generation() {
        let mut rng = StdRng::seed_from_u64(0u64);
        let comm_key = G1Affine::rand(&mut rng);
        let pk_gen_g1 = G1Affine::rand(&mut rng);
        let pk_gen_g2 = G2Affine::rand(&mut rng);

        fn check<PKG: AffineRepr, CMG: AffineRepr<ScalarField = PKG::ScalarField>>(
            rng: &mut StdRng,
            comm_key: CMG,
            pk_gen: &PKG,
        ) {
            for (threshold, total) in vec![
                (2, 2),
                (2, 3),
                (2, 4),
                (2, 5),
                (3, 3),
                (3, 4),
                (3, 5),
                (4, 5),
                (4, 8),
                (4, 9),
                (4, 12),
                (5, 5),
                (5, 7),
                (5, 10),
                (5, 13),
                (7, 10),
                (7, 15),
            ] {
                let mut all_round1s = vec![];
                let mut all_round2s = vec![];
                let mut all_secrets = vec![];
                let mut all_round1_msgs = vec![];
                let mut all_round2_msgs = vec![];

                println!("For {}-of-{}", threshold, total);
                let mut round1_time = Duration::default();
                let mut round2_time = Duration::default();

                // Each participant starts Round1
                for i in 1..=total {
                    let start = Instant::now();
                    let (round1, msgs) =
                        Round1::<_, DEFAULT_SALT_SIZE, DEFAULT_DIGEST_SIZE>::start::<
                            _,
                            Blake2b512,
                            CMG,
                        >(
                            rng,
                            i as ParticipantId,
                            threshold as ShareId,
                            total as ShareId,
                            comm_key,
                            pk_gen,
                        )
                        .unwrap();
                    round1_time += start.elapsed();

                    all_secrets.push(round1.secret.clone());
                    all_round1s.push(round1);
                    all_round1_msgs.push(msgs);
                }

                let start = Instant::now();
                // Each participant receives messages during Round1
                for i in 0..total {
                    for j in 0..total {
                        if i != j {
                            all_round1s[i]
                                .add_received_message(all_round1_msgs[j].clone())
                                .unwrap();
                        }
                    }
                }

                // Each participant ends round1 and begins Round 2
                for i in 0..total {
                    let (round2, msgs) = all_round1s[i].clone().finish().unwrap();
                    all_round2s.push(round2);
                    all_round2_msgs.push(msgs);
                }
                round1_time += start.elapsed();

                let start = Instant::now();
                // Each participant receives messages during Round2
                for i in 0..total {
                    for j in 0..total {
                        if i != j {
                            all_round2s[i]
                                .add_received_message(all_round2_msgs[j].clone())
                                .unwrap();
                        }
                    }
                }
                round2_time += start.elapsed();

                let start = Instant::now();
                // Each participant receives shares during Round2
                for i in 0..total {
                    for j in 0..total {
                        if i != j {
                            let share = all_round2s[j].round1_state.shares[i].clone();
                            all_round2s[i]
                                .add_received_share::<Blake2b512, CMG>(
                                    (j + 1) as ParticipantId,
                                    share,
                                    comm_key,
                                    pk_gen,
                                )
                                .unwrap();
                        }
                    }
                }
                round2_time += start.elapsed();

                for i in 0..total {
                    assert_eq!(all_round2s[i].received_msgs.len(), total - 1);
                    assert_eq!(all_round2s[i].received_shares.len(), total - 1);
                }

                // Each participant ends Round2 and ends up with his own keys and the threshold public key
                let mut tk = None;
                for i in 0..total {
                    let start = Instant::now();
                    let (own_sk, own_pk, threshold_pk) = all_round2s[i].clone().finish().unwrap();
                    round2_time += start.elapsed();
                    assert_eq!(own_sk, all_secrets[i]);
                    assert_eq!(
                        own_pk,
                        pk_gen.mul_bigint(own_sk.into_bigint()).into_affine()
                    );
                    if tk.is_none() {
                        tk = Some(threshold_pk);
                    } else {
                        // All generate the same threshold key
                        assert_eq!(tk, Some(threshold_pk))
                    }
                }

                assert_eq!(
                    tk.unwrap(),
                    (*pk_gen * all_secrets.into_iter().sum::<PKG::ScalarField>()).into_affine()
                );

                println!("Time taken for round 1 {:?}", round1_time);
                println!("Time taken for round 2 {:?}", round2_time);
            }
        }

        check(&mut rng, comm_key, &pk_gen_g1);
        check(&mut rng, comm_key, &pk_gen_g2);
    }
}
